#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS


__version__ = (2015, 12, 13, 10, 41, 1, 6)

__all__ = [
    'yepParser',
    'yepSemantics',
    'main'
]


class yepParser(Parser):
    def __init__(self,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re=None,
                 ignorecase=None,
                 left_recursion=True,
                 **kwargs):
        super(yepParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            **kwargs
        )

    @graken()
    def _yep_(self):
        self._expression_()
        self._check_eof()

    @graken()
    def _expression_(self):
        self._conditional_expression_()

    @graken()
    def _conditional_expression_(self):
        self._logical_or_expression_()
        self.ast['cond'] = self.last_node
        with self._optional():
            with self._group():
                self._token('?')
                self._expression_()
                self.ast['yes'] = self.last_node
                self._token(':')
                self._conditional_expression_()
                self.ast['no'] = self.last_node
            self.ast['val'] = self.last_node

        self.ast._define(
            ['cond', 'val', 'yes', 'no'],
            []
        )

    @graken()
    def _logical_or_expression_(self):
        self._logical_and_expression_()
        self.ast['l'] = self.last_node

        def block1():
            with self._group():
                self._OP_OR_()
                self._logical_and_expression_()
            self.ast.setlist('op_and_r', self.last_node)
        self._closure(block1)

        self.ast._define(
            ['l'],
            ['op_and_r']
        )

    @graken()
    def _logical_and_expression_(self):
        self._equality_expression_()
        self.ast['l'] = self.last_node

        def block1():
            with self._group():
                self._OP_AND_()
                self._equality_expression_()
            self.ast.setlist('op_and_r', self.last_node)
        self._closure(block1)

        self.ast._define(
            ['l'],
            ['op_and_r']
        )

    @graken()
    def _equality_expression_(self):
        self._relational_expression_()
        self.ast['l'] = self.last_node

        def block1():
            with self._group():
                self._OP_EQ_()
                self._relational_expression_()
            self.ast.setlist('op_and_r', self.last_node)
        self._closure(block1)

        self.ast._define(
            ['l'],
            ['op_and_r']
        )

    @graken()
    def _relational_expression_(self):
        self._unary_expression_()
        self.ast['l'] = self.last_node

        def block1():
            with self._group():
                self._OP_BINARY_()
                self._unary_expression_()
            self.ast.setlist('op_and_r', self.last_node)
        self._closure(block1)

        self.ast._define(
            ['l'],
            ['op_and_r']
        )

    @graken()
    def _unary_expression_(self):
        with self._choice():
            with self._option():
                self._OP_UNARY_()
                self.ast['op'] = self.last_node
                self._unary_expression_()
                self.ast['op_exp'] = self.last_node
            with self._option():
                self._primary_expression_()
                self.ast['exp'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['op', 'op_exp', 'exp'],
            []
        )

    @graken()
    def _primary_expression_(self):
        with self._choice():
            with self._option():
                self._constant_()
            with self._option():
                self._token('(')
                self._expression_()
                self.ast['@'] = self.last_node
                self._token(')')
            self._error('no available options')

    @graken()
    def _constant_(self):
        with self._choice():
            with self._option():
                self._number_()
            with self._option():
                self._string_()
            self._error('no available options')

    @graken()
    def _number_(self):
        self._pattern(r'\d+')

    @graken()
    def _string_(self):
        with self._choice():
            with self._option():
                self._simple_string_()
            with self._option():
                self._quoted_string_()
            self._error('no available options')

    @graken()
    def _simple_string_(self):
        with self._ifnot():
            self._KW_()
        self._pattern(r'[A-Za-z_](?:[A-Za-z_0-9.-]*[A-Za-z_])?')
        self.ast['@'] = self.last_node

    @graken()
    def _quoted_string_(self):
        with self._choice():
            with self._option():
                self._pattern(r'"')
                self._pattern(r'[^"\\]*(?:\\.[^"\\]*)*')
                self.ast['@'] = self.last_node
                self._pattern(r'"')
            with self._option():
                self._pattern(r"'")
                self._pattern(r"[^'\\]*(?:\\.[^'\\]*)*")
                self.ast['@'] = self.last_node
                self._pattern(r"'")
            self._error('expecting one of: " \'')

    @graken()
    def _OP_UNARY_(self):
        with self._choice():
            with self._option():
                self._token('!')
            with self._option():
                self._token('not')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('+')
            with self._option():
                self._token('-')
            with self._option():
                self._token('#')
            self._error('expecting one of: ! # + - not')

    @graken()
    def _OP_OR_(self):
        with self._choice():
            with self._option():
                self._token('or')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('||')
            self._error('expecting one of: or ||')

    @graken()
    def _OP_AND_(self):
        with self._choice():
            with self._option():
                self._token('and')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('&&')
            self._error('expecting one of: && and')

    @graken()
    def _OP_BINARY_(self):
        with self._choice():
            with self._option():
                self._token('<=')
            with self._option():
                self._token('le')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('<')
            with self._option():
                self._token('lt')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('ge')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('>')
            with self._option():
                self._token('gt')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('in')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                with self._group():
                    self._token('not')
                    self._pattern(r' +')
                    self._token('in')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            self._error('expecting one of: < <= > >= ge gt in le lt not')

    @graken()
    def _OP_ASGN_(self):
        self._token(':=')

    @graken()
    def _OP_EQ_(self):
        with self._choice():
            with self._option():
                self._token('==')
            with self._option():
                self._token('eq')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('ne')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('=~')
            with self._option():
                self._token('!~')
            with self._option():
                self._token('isa')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                with self._group():
                    self._token('is')
                    self._pattern(r' +')
                    self._token('not')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            with self._option():
                self._token('is')
                self.ast['@'] = self.last_node
                self._pattern(r'\b')
            self._error('expecting one of: != !~ == =~ eq is isa ne')

    @graken()
    def _KW_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('return')
                with self._option():
                    self._token('def')
                with self._option():
                    self._token('sub')
                with self._option():
                    self._token('func')
                with self._option():
                    self._token('do')
                with self._option():
                    self._token('end')
                with self._option():
                    self._token('if')
                with self._option():
                    self._token('elif')
                with self._option():
                    self._token('else')
                with self._option():
                    self._token('for')
                with self._option():
                    self._token('while')
                with self._option():
                    self._token('repeat')
                with self._option():
                    self._token('until')
                with self._option():
                    self._token('next')
                with self._option():
                    self._token('break')
                with self._option():
                    self._token('continue')
                with self._option():
                    self._token('var')
                with self._option():
                    self._token('goto')
                with self._option():
                    self._token('with')
                with self._option():
                    self._token('true')
                with self._option():
                    self._token('false')
                with self._option():
                    self._token('nil')
                with self._option():
                    self._token('null')
                with self._option():
                    self._token('undef')
                with self._option():
                    self._token('not')
                with self._option():
                    self._token('and')
                with self._option():
                    self._token('or')
                with self._option():
                    self._token('isa')
                with self._option():
                    self._token('is')
                with self._option():
                    self._token('in')
                with self._option():
                    self._token('eq')
                with self._option():
                    self._token('ne')
                with self._option():
                    self._token('gt')
                with self._option():
                    self._token('ge')
                with self._option():
                    self._token('lt')
                with self._option():
                    self._token('le')
                self._error('expecting one of: and break continue def do elif else end eq false for func ge goto gt if in is isa le lt ne next nil not null or repeat return sub true undef until var while with')
        self._pattern(r'\b')

    @graken()
    def _WS_(self):
        self._pattern(r'\s+')


class yepSemantics(object):
    def yep(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def conditional_expression(self, ast):
        return ast

    def logical_or_expression(self, ast):
        return ast

    def logical_and_expression(self, ast):
        return ast

    def equality_expression(self, ast):
        return ast

    def relational_expression(self, ast):
        return ast

    def unary_expression(self, ast):
        return ast

    def primary_expression(self, ast):
        return ast

    def constant(self, ast):
        return ast

    def number(self, ast):
        return ast

    def string(self, ast):
        return ast

    def simple_string(self, ast):
        return ast

    def quoted_string(self, ast):
        return ast

    def OP_UNARY(self, ast):
        return ast

    def OP_OR(self, ast):
        return ast

    def OP_AND(self, ast):
        return ast

    def OP_BINARY(self, ast):
        return ast

    def OP_ASGN(self, ast):
        return ast

    def OP_EQ(self, ast):
        return ast

    def KW(self, ast):
        return ast

    def WS(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None, nameguard=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = yepParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in yepParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for yep.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-n', '--no-nameguard', action='store_true',
                        dest='no_nameguard',
                        help="disable the 'nameguard' feature")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(
        args.file,
        args.startrule,
        trace=args.trace,
        whitespace=args.whitespace,
        nameguard=not args.no_nameguard
    )

